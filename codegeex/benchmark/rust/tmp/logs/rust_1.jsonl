{"reason":"compiler-artifact","package_id":"registry+https://github.com/rust-lang/crates.io-index#md5@0.7.0","manifest_path":"/root/.cargo/registry/src/index.crates.io-6f17d22bba15001f/md5-0.7.0/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"md5","src_path":"/root/.cargo/registry/src/index.crates.io-6f17d22bba15001f/md5-0.7.0/src/lib.rs","edition":"2015","doc":true,"doctest":true,"test":true},"profile":{"opt_level":"0","debuginfo":2,"debug_assertions":true,"overflow_checks":true,"test":false},"features":["default","std"],"filenames":["/workspace/CodeGeeX/codegeex/benchmark/rust/target/debug/deps/libmd5-f4743d12352c0fc6.rmeta"],"executable":null,"fresh":false}
{"reason":"compiler-artifact","package_id":"registry+https://github.com/rust-lang/crates.io-index#libc@0.2.139","manifest_path":"/root/.cargo/registry/src/index.crates.io-6f17d22bba15001f/libc-0.2.139/Cargo.toml","target":{"kind":["custom-build"],"crate_types":["bin"],"name":"build-script-build","src_path":"/root/.cargo/registry/src/index.crates.io-6f17d22bba15001f/libc-0.2.139/build.rs","edition":"2015","doc":false,"doctest":false,"test":false},"profile":{"opt_level":"0","debuginfo":0,"debug_assertions":true,"overflow_checks":true,"test":false},"features":["default","std"],"filenames":["/workspace/CodeGeeX/codegeex/benchmark/rust/target/debug/build/libc-df7e263b76b63be0/build-script-build"],"executable":null,"fresh":false}
{"reason":"compiler-artifact","package_id":"registry+https://github.com/rust-lang/crates.io-index#memchr@2.5.0","manifest_path":"/root/.cargo/registry/src/index.crates.io-6f17d22bba15001f/memchr-2.5.0/Cargo.toml","target":{"kind":["custom-build"],"crate_types":["bin"],"name":"build-script-build","src_path":"/root/.cargo/registry/src/index.crates.io-6f17d22bba15001f/memchr-2.5.0/build.rs","edition":"2018","doc":false,"doctest":false,"test":false},"profile":{"opt_level":"0","debuginfo":0,"debug_assertions":true,"overflow_checks":true,"test":false},"features":["default","std"],"filenames":["/workspace/CodeGeeX/codegeex/benchmark/rust/target/debug/build/memchr-cb79429ef7525660/build-script-build"],"executable":null,"fresh":false}
{"reason":"build-script-executed","package_id":"registry+https://github.com/rust-lang/crates.io-index#memchr@2.5.0","linked_libs":[],"linked_paths":[],"cfgs":["memchr_runtime_simd","memchr_runtime_sse2","memchr_runtime_sse42","memchr_runtime_avx"],"env":[],"out_dir":"/workspace/CodeGeeX/codegeex/benchmark/rust/target/debug/build/memchr-0655e93f9f0854d8/out"}
{"reason":"build-script-executed","package_id":"registry+https://github.com/rust-lang/crates.io-index#libc@0.2.139","linked_libs":[],"linked_paths":[],"cfgs":["freebsd11","libc_priv_mod_use","libc_union","libc_const_size_of","libc_align","libc_int128","libc_core_cvoid","libc_packedN","libc_cfg_target_vendor","libc_non_exhaustive","libc_ptr_addr_of","libc_underscore_const_names","libc_const_extern_fn"],"env":[],"out_dir":"/workspace/CodeGeeX/codegeex/benchmark/rust/target/debug/build/libc-d1e8eba0f5b5e6ec/out"}
{"reason":"compiler-artifact","package_id":"registry+https://github.com/rust-lang/crates.io-index#memchr@2.5.0","manifest_path":"/root/.cargo/registry/src/index.crates.io-6f17d22bba15001f/memchr-2.5.0/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"memchr","src_path":"/root/.cargo/registry/src/index.crates.io-6f17d22bba15001f/memchr-2.5.0/src/lib.rs","edition":"2018","doc":true,"doctest":true,"test":true},"profile":{"opt_level":"0","debuginfo":2,"debug_assertions":true,"overflow_checks":true,"test":false},"features":["default","std"],"filenames":["/workspace/CodeGeeX/codegeex/benchmark/rust/target/debug/deps/libmemchr-4335691aa5ee1cde.rmeta"],"executable":null,"fresh":false}
{"reason":"compiler-artifact","package_id":"registry+https://github.com/rust-lang/crates.io-index#libc@0.2.139","manifest_path":"/root/.cargo/registry/src/index.crates.io-6f17d22bba15001f/libc-0.2.139/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"libc","src_path":"/root/.cargo/registry/src/index.crates.io-6f17d22bba15001f/libc-0.2.139/src/lib.rs","edition":"2015","doc":true,"doctest":true,"test":true},"profile":{"opt_level":"0","debuginfo":2,"debug_assertions":true,"overflow_checks":true,"test":false},"features":["default","std"],"filenames":["/workspace/CodeGeeX/codegeex/benchmark/rust/target/debug/deps/liblibc-42137c015bf90361.rmeta"],"executable":null,"fresh":false}
{"reason":"compiler-artifact","package_id":"registry+https://github.com/rust-lang/crates.io-index#aho-corasick@0.7.20","manifest_path":"/root/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aho-corasick-0.7.20/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"aho_corasick","src_path":"/root/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aho-corasick-0.7.20/src/lib.rs","edition":"2018","doc":true,"doctest":true,"test":true},"profile":{"opt_level":"0","debuginfo":2,"debug_assertions":true,"overflow_checks":true,"test":false},"features":["default","std"],"filenames":["/workspace/CodeGeeX/codegeex/benchmark/rust/target/debug/deps/libaho_corasick-80553f3f92c84c60.rmeta"],"executable":null,"fresh":false}
{"reason":"compiler-artifact","package_id":"registry+https://github.com/rust-lang/crates.io-index#regex-syntax@0.6.28","manifest_path":"/root/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.6.28/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"regex-syntax","src_path":"/root/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.6.28/src/lib.rs","edition":"2018","doc":true,"doctest":true,"test":true},"profile":{"opt_level":"0","debuginfo":2,"debug_assertions":true,"overflow_checks":true,"test":false},"features":["default","unicode","unicode-age","unicode-bool","unicode-case","unicode-gencat","unicode-perl","unicode-script","unicode-segment"],"filenames":["/workspace/CodeGeeX/codegeex/benchmark/rust/target/debug/deps/libregex_syntax-87b5fd2c0c3bd78b.rmeta"],"executable":null,"fresh":false}
{"reason":"compiler-artifact","package_id":"registry+https://github.com/rust-lang/crates.io-index#rand@0.4.6","manifest_path":"/root/.cargo/registry/src/index.crates.io-6f17d22bba15001f/rand-0.4.6/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"rand","src_path":"/root/.cargo/registry/src/index.crates.io-6f17d22bba15001f/rand-0.4.6/src/lib.rs","edition":"2015","doc":true,"doctest":true,"test":true},"profile":{"opt_level":"0","debuginfo":2,"debug_assertions":true,"overflow_checks":true,"test":false},"features":["default","libc","std"],"filenames":["/workspace/CodeGeeX/codegeex/benchmark/rust/target/debug/deps/librand-815e695e3ad827cf.rmeta"],"executable":null,"fresh":false}
{"reason":"compiler-artifact","package_id":"registry+https://github.com/rust-lang/crates.io-index#regex@1.7.1","manifest_path":"/root/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-1.7.1/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"regex","src_path":"/root/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-1.7.1/src/lib.rs","edition":"2018","doc":true,"doctest":false,"test":true},"profile":{"opt_level":"0","debuginfo":2,"debug_assertions":true,"overflow_checks":true,"test":false},"features":["aho-corasick","default","memchr","perf","perf-cache","perf-dfa","perf-inline","perf-literal","std","unicode","unicode-age","unicode-bool","unicode-case","unicode-gencat","unicode-perl","unicode-script","unicode-segment"],"filenames":["/workspace/CodeGeeX/codegeex/benchmark/rust/target/debug/deps/libregex-d47ac63891b392cd.rmeta"],"executable":null,"fresh":false}
{"reason":"compiler-message","package_id":"path+file:///workspace/CodeGeeX/codegeex/benchmark/rust#0.1.0","manifest_path":"/workspace/CodeGeeX/codegeex/benchmark/rust/Cargo.toml","target":{"kind":["bin"],"crate_types":["bin"],"name":"rust_1","src_path":"/workspace/CodeGeeX/codegeex/benchmark/rust/src/bin/rust_1.rs","edition":"2021","doc":true,"doctest":false,"test":true},"message":{"rendered":"error: unknown start of token: \\\n  --> src/bin/rust_1.rs:23:24\n   |\n23 |     if (!str[i].match(/\\(/)) break\n   |                        ^\n\n","$message_type":"diagnostic","children":[],"code":null,"level":"error","message":"unknown start of token: \\","spans":[{"byte_end":738,"byte_start":737,"column_end":25,"column_start":24,"expansion":null,"file_name":"src/bin/rust_1.rs","is_primary":true,"label":null,"line_end":23,"line_start":23,"suggested_replacement":null,"suggestion_applicability":null,"text":[{"highlight_end":25,"highlight_start":24,"text":"    if (!str[i].match(/\\(/)) break"}]}]}}
{"reason":"compiler-message","package_id":"path+file:///workspace/CodeGeeX/codegeex/benchmark/rust#0.1.0","manifest_path":"/workspace/CodeGeeX/codegeex/benchmark/rust/Cargo.toml","target":{"kind":["bin"],"crate_types":["bin"],"name":"rust_1","src_path":"/workspace/CodeGeeX/codegeex/benchmark/rust/src/bin/rust_1.rs","edition":"2021","doc":true,"doctest":false,"test":true},"message":{"rendered":"error: unknown start of token: \\\n  --> src/bin/rust_1.rs:24:29\n   |\n24 |     else if (str[i].match(/(\\w+)\\s*?\\)/)) { // a word with parentheses after it, e.g., (\"foo\" (bar baz))\n   |                             ^\n\n","$message_type":"diagnostic","children":[],"code":null,"level":"error","message":"unknown start of token: \\","spans":[{"byte_end":778,"byte_start":777,"column_end":30,"column_start":29,"expansion":null,"file_name":"src/bin/rust_1.rs","is_primary":true,"label":null,"line_end":24,"line_start":24,"suggested_replacement":null,"suggestion_applicability":null,"text":[{"highlight_end":30,"highlight_start":29,"text":"    else if (str[i].match(/(\\w+)\\s*?\\)/)) { // a word with parentheses after it, e.g., (\"foo\" (bar baz))"}]}]}}
{"reason":"compiler-message","package_id":"path+file:///workspace/CodeGeeX/codegeex/benchmark/rust#0.1.0","manifest_path":"/workspace/CodeGeeX/codegeex/benchmark/rust/Cargo.toml","target":{"kind":["bin"],"crate_types":["bin"],"name":"rust_1","src_path":"/workspace/CodeGeeX/codegeex/benchmark/rust/src/bin/rust_1.rs","edition":"2021","doc":true,"doctest":false,"test":true},"message":{"rendered":"error: unknown start of token: \\\n  --> src/bin/rust_1.rs:24:33\n   |\n24 |     else if (str[i].match(/(\\w+)\\s*?\\)/)) { // a word with parentheses after it, e.g., (\"foo\" (bar baz))\n   |                                 ^\n\n","$message_type":"diagnostic","children":[],"code":null,"level":"error","message":"unknown start of token: \\","spans":[{"byte_end":782,"byte_start":781,"column_end":34,"column_start":33,"expansion":null,"file_name":"src/bin/rust_1.rs","is_primary":true,"label":null,"line_end":24,"line_start":24,"suggested_replacement":null,"suggestion_applicability":null,"text":[{"highlight_end":34,"highlight_start":33,"text":"    else if (str[i].match(/(\\w+)\\s*?\\)/)) { // a word with parentheses after it, e.g., (\"foo\" (bar baz))"}]}]}}
{"reason":"compiler-message","package_id":"path+file:///workspace/CodeGeeX/codegeex/benchmark/rust#0.1.0","manifest_path":"/workspace/CodeGeeX/codegeex/benchmark/rust/Cargo.toml","target":{"kind":["bin"],"crate_types":["bin"],"name":"rust_1","src_path":"/workspace/CodeGeeX/codegeex/benchmark/rust/src/bin/rust_1.rs","edition":"2021","doc":true,"doctest":false,"test":true},"message":{"rendered":"error: unknown start of token: \\\n  --> src/bin/rust_1.rs:24:37\n   |\n24 |     else if (str[i].match(/(\\w+)\\s*?\\)/)) { // a word with parentheses after it, e.g., (\"foo\" (bar baz))\n   |                                     ^\n\n","$message_type":"diagnostic","children":[],"code":null,"level":"error","message":"unknown start of token: \\","spans":[{"byte_end":786,"byte_start":785,"column_end":38,"column_start":37,"expansion":null,"file_name":"src/bin/rust_1.rs","is_primary":true,"label":null,"line_end":24,"line_start":24,"suggested_replacement":null,"suggestion_applicability":null,"text":[{"highlight_end":38,"highlight_start":37,"text":"    else if (str[i].match(/(\\w+)\\s*?\\)/)) { // a word with parentheses after it, e.g., (\"foo\" (bar baz))"}]}]}}
{"reason":"compiler-message","package_id":"path+file:///workspace/CodeGeeX/codegeex/benchmark/rust#0.1.0","manifest_path":"/workspace/CodeGeeX/codegeex/benchmark/rust/Cargo.toml","target":{"kind":["bin"],"crate_types":["bin"],"name":"rust_1","src_path":"/workspace/CodeGeeX/codegeex/benchmark/rust/src/bin/rust_1.rs","edition":"2021","doc":true,"doctest":false,"test":true},"message":{"rendered":"error: unknown start of token: \\\n  --> src/bin/rust_1.rs:27:58\n   |\n27 |       while (!str[stack[stack.length - 1].length].match(/\\w+/)) { // as long as there is no word before the parentheses, continue pushing...\n   |                                                          ^\n\n","$message_type":"diagnostic","children":[],"code":null,"level":"error","message":"unknown start of token: \\","spans":[{"byte_end":1018,"byte_start":1017,"column_end":59,"column_start":58,"expansion":null,"file_name":"src/bin/rust_1.rs","is_primary":true,"label":null,"line_end":27,"line_start":27,"suggested_replacement":null,"suggestion_applicability":null,"text":[{"highlight_end":59,"highlight_start":58,"text":"      while (!str[stack[stack.length - 1].length].match(/\\w+/)) { // as long as there is no word before the parentheses, continue pushing them onto the stack"}]}]}}
{"reason":"compiler-message","package_id":"path+file:///workspace/CodeGeeX/codegeex/benchmark/rust#0.1.0","manifest_path":"/workspace/CodeGeeX/codegeex/benchmark/rust/Cargo.toml","target":{"kind":["bin"],"crate_types":["bin"],"name":"rust_1","src_path":"/workspace/CodeGeeX/codegeex/benchmark/rust/src/bin/rust_1.rs","edition":"2021","doc":true,"doctest":false,"test":true},"message":{"rendered":"error: unknown start of token: \\\n  --> src/bin/rust_1.rs:35:33\n   |\n35 |       let r = str[i + 1].match(/\\w+(?=\\))/) // word immediately after parentheses (which ends in )/), e.g., (\"foo\" (bar baz))\n   |                                 ^\n\n","$message_type":"diagnostic","children":[],"code":null,"level":"error","message":"unknown start of token: \\","spans":[{"byte_end":1402,"byte_start":1401,"column_end":34,"column_start":33,"expansion":null,"file_name":"src/bin/rust_1.rs","is_primary":true,"label":null,"line_end":35,"line_start":35,"suggested_replacement":null,"suggestion_applicability":null,"text":[{"highlight_end":34,"highlight_start":33,"text":"      let r = str[i + 1].match(/\\w+(?=\\))/) // word immediately after parentheses (which ends in )/), e.g., (\"foo\" (bar baz))"}]}]}}
{"reason":"compiler-message","package_id":"path+file:///workspace/CodeGeeX/codegeex/benchmark/rust#0.1.0","manifest_path":"/workspace/CodeGeeX/codegeex/benchmark/rust/Cargo.toml","target":{"kind":["bin"],"crate_types":["bin"],"name":"rust_1","src_path":"/workspace/CodeGeeX/codegeex/benchmark/rust/src/bin/rust_1.rs","edition":"2021","doc":true,"doctest":false,"test":true},"message":{"rendered":"error: unknown start of token: \\\n  --> src/bin/rust_1.rs:35:39\n   |\n35 |       let r = str[i + 1].match(/\\w+(?=\\))/) // word immediately after parentheses (which ends in )/), e.g., (\"foo\" (bar baz))\n   |                                       ^\n\n","$message_type":"diagnostic","children":[],"code":null,"level":"error","message":"unknown start of token: \\","spans":[{"byte_end":1408,"byte_start":1407,"column_end":40,"column_start":39,"expansion":null,"file_name":"src/bin/rust_1.rs","is_primary":true,"label":null,"line_end":35,"line_start":35,"suggested_replacement":null,"suggestion_applicability":null,"text":[{"highlight_end":40,"highlight_start":39,"text":"      let r = str[i + 1].match(/\\w+(?=\\))/) // word immediately after parentheses (which ends in )/), e.g., (\"foo\" (bar baz))"}]}]}}
{"reason":"compiler-message","package_id":"path+file:///workspace/CodeGeeX/codegeex/benchmark/rust#0.1.0","manifest_path":"/workspace/CodeGeeX/codegeex/benchmark/rust/Cargo.toml","target":{"kind":["bin"],"crate_types":["bin"],"name":"rust_1","src_path":"/workspace/CodeGeeX/codegeex/benchmark/rust/src/bin/rust_1.rs","edition":"2021","doc":true,"doctest":false,"test":true},"message":{"rendered":"error: empty character literal\n  --> src/bin/rust_1.rs:36:29\n   |\n36 |       while (r && r[1] !== '') { // as long as there is a word after the parentheses, push that word onto the stack\n   |                             ^ empty character literal\n\n","$message_type":"diagnostic","children":[],"code":null,"level":"error","message":"empty character literal","spans":[{"byte_end":1523,"byte_start":1523,"column_end":29,"column_start":29,"expansion":null,"file_name":"src/bin/rust_1.rs","is_primary":true,"label":"empty character literal","line_end":36,"line_start":36,"suggested_replacement":null,"suggestion_applicability":null,"text":[{"highlight_end":29,"highlight_start":29,"text":"      while (r && r[1] !== '') { // as long as there is a word after the parentheses, push that word onto the stack"}]}]}}
{"reason":"compiler-message","package_id":"path+file:///workspace/CodeGeeX/codegeex/benchmark/rust#0.1.0","manifest_path":"/workspace/CodeGeeX/codegeex/benchmark/rust/Cargo.toml","target":{"kind":["bin"],"crate_types":["bin"],"name":"rust_1","src_path":"/workspace/CodeGeeX/codegeex/benchmark/rust/src/bin/rust_1.rs","edition":"2021","doc":true,"doctest":false,"test":true},"message":{"rendered":"error: unknown start of token: \\\n  --> src/bin/rust_1.rs:37:35\n   |\n37 |         let s = str[i + 1].match(/\\w+/) // extract current word from string\n   |                                   ^\n\n","$message_type":"diagnostic","children":[],"code":null,"level":"error","message":"unknown start of token: \\","spans":[{"byte_end":1646,"byte_start":1645,"column_end":36,"column_start":35,"expansion":null,"file_name":"src/bin/rust_1.rs","is_primary":true,"label":null,"line_end":37,"line_start":37,"suggested_replacement":null,"suggestion_applicability":null,"text":[{"highlight_end":36,"highlight_start":35,"text":"        let s = str[i + 1].match(/\\w+/) // extract current word from string"}]}]}}
{"reason":"compiler-message","package_id":"path+file:///workspace/CodeGeeX/codegeex/benchmark/rust#0.1.0","manifest_path":"/workspace/CodeGeeX/codegeex/benchmark/rust/Cargo.toml","target":{"kind":["bin"],"crate_types":["bin"],"name":"rust_1","src_path":"/workspace/CodeGeeX/codegeex/benchmark/rust/src/bin/rust_1.rs","edition":"2021","doc":true,"doctest":false,"test":true},"message":{"rendered":"error: unknown start of token: \\\n  --> src/bin/rust_1.rs:38:65\n   |\n38 | ...   while (!str[stack[stack.length - 1].length + 1].match(/(\\w+)\\s*?\\)/)) { // as long as there is no word after the parentheses, conti...\n   |                                                               ^\n\n","$message_type":"diagnostic","children":[],"code":null,"level":"error","message":"unknown start of token: \\","spans":[{"byte_end":1752,"byte_start":1751,"column_end":66,"column_start":65,"expansion":null,"file_name":"src/bin/rust_1.rs","is_primary":true,"label":null,"line_end":38,"line_start":38,"suggested_replacement":null,"suggestion_applicability":null,"text":[{"highlight_end":66,"highlight_start":65,"text":"        while (!str[stack[stack.length - 1].length + 1].match(/(\\w+)\\s*?\\)/)) { // as long as there is no word after the parentheses, continue pushing that onto the stack"}]}]}}
{"reason":"compiler-message","package_id":"path+file:///workspace/CodeGeeX/codegeex/benchmark/rust#0.1.0","manifest_path":"/workspace/CodeGeeX/codegeex/benchmark/rust/Cargo.toml","target":{"kind":["bin"],"crate_types":["bin"],"name":"rust_1","src_path":"/workspace/CodeGeeX/codegeex/benchmark/rust/src/bin/rust_1.rs","edition":"2021","doc":true,"doctest":false,"test":true},"message":{"rendered":"error: unknown start of token: \\\n  --> src/bin/rust_1.rs:38:69\n   |\n38 | ...   while (!str[stack[stack.length - 1].length + 1].match(/(\\w+)\\s*?\\)/)) { // as long as there is no word after the parentheses, conti...\n   |                                                                   ^\n\n","$message_type":"diagnostic","children":[],"code":null,"level":"error","message":"unknown start of token: \\","spans":[{"byte_end":1756,"byte_start":1755,"column_end":70,"column_start":69,"expansion":null,"file_name":"src/bin/rust_1.rs","is_primary":true,"label":null,"line_end":38,"line_start":38,"suggested_replacement":null,"suggestion_applicability":null,"text":[{"highlight_end":70,"highlight_start":69,"text":"        while (!str[stack[stack.length - 1].length + 1].match(/(\\w+)\\s*?\\)/)) { // as long as there is no word after the parentheses, continue pushing that onto the stack"}]}]}}
{"reason":"compiler-message","package_id":"path+file:///workspace/CodeGeeX/codegeex/benchmark/rust#0.1.0","manifest_path":"/workspace/CodeGeeX/codegeex/benchmark/rust/Cargo.toml","target":{"kind":["bin"],"crate_types":["bin"],"name":"rust_1","src_path":"/workspace/CodeGeeX/codegeex/benchmark/rust/src/bin/rust_1.rs","edition":"2021","doc":true,"doctest":false,"test":true},"message":{"rendered":"error: unknown start of token: \\\n  --> src/bin/rust_1.rs:38:73\n   |\n38 | ...   while (!str[stack[stack.length - 1].length + 1].match(/(\\w+)\\s*?\\)/)) { // as long as there is no word after the parentheses, conti...\n   |                                                                       ^\n\n","$message_type":"diagnostic","children":[],"code":null,"level":"error","message":"unknown start of token: \\","spans":[{"byte_end":1760,"byte_start":1759,"column_end":74,"column_start":73,"expansion":null,"file_name":"src/bin/rust_1.rs","is_primary":true,"label":null,"line_end":38,"line_start":38,"suggested_replacement":null,"suggestion_applicability":null,"text":[{"highlight_end":74,"highlight_start":73,"text":"        while (!str[stack[stack.length - 1].length + 1].match(/(\\w+)\\s*?\\)/)) { // as long as there is no word after the parentheses, continue pushing that onto the stack"}]}]}}
{"reason":"compiler-message","package_id":"path+file:///workspace/CodeGeeX/codegeex/benchmark/rust#0.1.0","manifest_path":"/workspace/CodeGeeX/codegeex/benchmark/rust/Cargo.toml","target":{"kind":["bin"],"crate_types":["bin"],"name":"rust_1","src_path":"/workspace/CodeGeeX/codegeex/benchmark/rust/src/bin/rust_1.rs","edition":"2021","doc":true,"doctest":false,"test":true},"message":{"rendered":"error: unknown start of token: \\\n  --> src/bin/rust_1.rs:46:31\n   |\n46 |         r = str[i + 2].match(/\\w+(?=\\))/) // extract next word after parentheses (which ends in )/), e.g., (\"foo\" (bar baz))\n   |                               ^\n\n","$message_type":"diagnostic","children":[],"code":null,"level":"error","message":"unknown start of token: \\","spans":[{"byte_end":2144,"byte_start":2143,"column_end":32,"column_start":31,"expansion":null,"file_name":"src/bin/rust_1.rs","is_primary":true,"label":null,"line_end":46,"line_start":46,"suggested_replacement":null,"suggestion_applicability":null,"text":[{"highlight_end":32,"highlight_start":31,"text":"        r = str[i + 2].match(/\\w+(?=\\))/) // extract next word after parentheses (which ends in )/), e.g., (\"foo\" (bar baz))"}]}]}}
{"reason":"compiler-message","package_id":"path+file:///workspace/CodeGeeX/codegeex/benchmark/rust#0.1.0","manifest_path":"/workspace/CodeGeeX/codegeex/benchmark/rust/Cargo.toml","target":{"kind":["bin"],"crate_types":["bin"],"name":"rust_1","src_path":"/workspace/CodeGeeX/codegeex/benchmark/rust/src/bin/rust_1.rs","edition":"2021","doc":true,"doctest":false,"test":true},"message":{"rendered":"error: unknown start of token: \\\n  --> src/bin/rust_1.rs:46:37\n   |\n46 |         r = str[i + 2].match(/\\w+(?=\\))/) // extract next word after parentheses (which ends in )/), e.g., (\"foo\" (bar baz))\n   |                                     ^\n\n","$message_type":"diagnostic","children":[],"code":null,"level":"error","message":"unknown start of token: \\","spans":[{"byte_end":2150,"byte_start":2149,"column_end":38,"column_start":37,"expansion":null,"file_name":"src/bin/rust_1.rs","is_primary":true,"label":null,"line_end":46,"line_start":46,"suggested_replacement":null,"suggestion_applicability":null,"text":[{"highlight_end":38,"highlight_start":37,"text":"        r = str[i + 2].match(/\\w+(?=\\))/) // extract next word after parentheses (which ends in )/), e.g., (\"foo\" (bar baz))"}]}]}}
{"reason":"compiler-message","package_id":"path+file:///workspace/CodeGeeX/codegeex/benchmark/rust#0.1.0","manifest_path":"/workspace/CodeGeeX/codegeex/benchmark/rust/Cargo.toml","target":{"kind":["bin"],"crate_types":["bin"],"name":"rust_1","src_path":"/workspace/CodeGeeX/codegeex/benchmark/rust/src/bin/rust_1.rs","edition":"2021","doc":true,"doctest":false,"test":true},"message":{"rendered":"error: mismatched closing delimiter: `)`\n  --> src/bin/rust_1.rs:29:22\n   |\n29 |           stack.push([']')\n   |                     -^   ^ mismatched closing delimiter\n   |                     ||\n   |                     |unclosed delimiter\n   |                     closing delimiter possibly meant for this\n\n","$message_type":"diagnostic","children":[],"code":null,"level":"error","message":"mismatched closing delimiter: `)`","spans":[{"byte_end":1295,"byte_start":1294,"column_end":27,"column_start":26,"expansion":null,"file_name":"src/bin/rust_1.rs","is_primary":true,"label":"mismatched closing delimiter","line_end":29,"line_start":29,"suggested_replacement":null,"suggestion_applicability":null,"text":[{"highlight_end":27,"highlight_start":26,"text":"          stack.push([']')"}]},{"byte_end":1290,"byte_start":1289,"column_end":22,"column_start":21,"expansion":null,"file_name":"src/bin/rust_1.rs","is_primary":false,"label":"closing delimiter possibly meant for this","line_end":29,"line_start":29,"suggested_replacement":null,"suggestion_applicability":null,"text":[{"highlight_end":22,"highlight_start":21,"text":"          stack.push([']')"}]},{"byte_end":1291,"byte_start":1290,"column_end":23,"column_start":22,"expansion":null,"file_name":"src/bin/rust_1.rs","is_primary":true,"label":"unclosed delimiter","line_end":29,"line_start":29,"suggested_replacement":null,"suggestion_applicability":null,"text":[{"highlight_end":23,"highlight_start":22,"text":"          stack.push([']')"}]}]}}
{"reason":"compiler-message","package_id":"path+file:///workspace/CodeGeeX/codegeex/benchmark/rust#0.1.0","manifest_path":"/workspace/CodeGeeX/codegeex/benchmark/rust/Cargo.toml","target":{"kind":["bin"],"crate_types":["bin"],"name":"rust_1","src_path":"/workspace/CodeGeeX/codegeex/benchmark/rust/src/bin/rust_1.rs","edition":"2021","doc":true,"doctest":false,"test":true},"message":{"rendered":"error: mismatched closing delimiter: `)`\n  --> src/bin/rust_1.rs:24:43\n   |\n24 |     else if (str[i].match(/(\\w+)\\s*?\\)/)) { // a word with parentheses after it, e.g., (\"foo\" (bar baz))\n   |                                           ^ unclosed delimiter\n...\n35 |       let r = str[i + 1].match(/\\w+(?=\\))/) // word immediately after parentheses (which ends in )/), e.g., (\"foo\" (bar baz))\n   |                                           ^ mismatched closing delimiter\n\n","$message_type":"diagnostic","children":[],"code":null,"level":"error","message":"mismatched closing delimiter: `)`","spans":[{"byte_end":1412,"byte_start":1411,"column_end":44,"column_start":43,"expansion":null,"file_name":"src/bin/rust_1.rs","is_primary":true,"label":"mismatched closing delimiter","line_end":35,"line_start":35,"suggested_replacement":null,"suggestion_applicability":null,"text":[{"highlight_end":44,"highlight_start":43,"text":"      let r = str[i + 1].match(/\\w+(?=\\))/) // word immediately after parentheses (which ends in )/), e.g., (\"foo\" (bar baz))"}]},{"byte_end":792,"byte_start":791,"column_end":44,"column_start":43,"expansion":null,"file_name":"src/bin/rust_1.rs","is_primary":true,"label":"unclosed delimiter","line_end":24,"line_start":24,"suggested_replacement":null,"suggestion_applicability":null,"text":[{"highlight_end":44,"highlight_start":43,"text":"    else if (str[i].match(/(\\w+)\\s*?\\)/)) { // a word with parentheses after it, e.g., (\"foo\" (bar baz))"}]}]}}
{"reason":"compiler-message","package_id":"path+file:///workspace/CodeGeeX/codegeex/benchmark/rust#0.1.0","manifest_path":"/workspace/CodeGeeX/codegeex/benchmark/rust/Cargo.toml","target":{"kind":["bin"],"crate_types":["bin"],"name":"rust_1","src_path":"/workspace/CodeGeeX/codegeex/benchmark/rust/src/bin/rust_1.rs","edition":"2021","doc":true,"doctest":false,"test":true},"message":{"rendered":"error: mismatched closing delimiter: `)`\n  --> src/bin/rust_1.rs:36:32\n   |\n36 |       while (r && r[1] !== '') { // as long as there is a word after the parentheses, push that word onto the stack\n   |                                ^ unclosed delimiter\n37 |         let s = str[i + 1].match(/\\w+/) // extract current word from string\n38 |         while (!str[stack[stack.length - 1].length + 1].match(/(\\w+)\\s*?\\)/)) { // as long as there is no word after the parentheses, con...\n   |                                                                             ^ mismatched closing delimiter\n\n","$message_type":"diagnostic","children":[],"code":null,"level":"error","message":"mismatched closing delimiter: `)`","spans":[{"byte_end":1764,"byte_start":1763,"column_end":78,"column_start":77,"expansion":null,"file_name":"src/bin/rust_1.rs","is_primary":true,"label":"mismatched closing delimiter","line_end":38,"line_start":38,"suggested_replacement":null,"suggestion_applicability":null,"text":[{"highlight_end":78,"highlight_start":77,"text":"        while (!str[stack[stack.length - 1].length + 1].match(/(\\w+)\\s*?\\)/)) { // as long as there is no word after the parentheses, continue pushing that onto the stack"}]},{"byte_end":1527,"byte_start":1526,"column_end":33,"column_start":32,"expansion":null,"file_name":"src/bin/rust_1.rs","is_primary":true,"label":"unclosed delimiter","line_end":36,"line_start":36,"suggested_replacement":null,"suggestion_applicability":null,"text":[{"highlight_end":33,"highlight_start":32,"text":"      while (r && r[1] !== '') { // as long as there is a word after the parentheses, push that word onto the stack"}]}]}}
{"reason":"compiler-message","package_id":"path+file:///workspace/CodeGeeX/codegeex/benchmark/rust#0.1.0","manifest_path":"/workspace/CodeGeeX/codegeex/benchmark/rust/Cargo.toml","target":{"kind":["bin"],"crate_types":["bin"],"name":"rust_1","src_path":"/workspace/CodeGeeX/codegeex/benchmark/rust/src/bin/rust_1.rs","edition":"2021","doc":true,"doctest":false,"test":true},"message":{"rendered":"error: mismatched closing delimiter: `)`\n  --> src/bin/rust_1.rs:40:24\n   |\n40 |             stack.push([']')\n   |                       -^   ^ mismatched closing delimiter\n   |                       ||\n   |                       |unclosed delimiter\n   |                       closing delimiter possibly meant for this\n\n","$message_type":"diagnostic","children":[],"code":null,"level":"error","message":"mismatched closing delimiter: `)`","spans":[{"byte_end":2029,"byte_start":2028,"column_end":29,"column_start":28,"expansion":null,"file_name":"src/bin/rust_1.rs","is_primary":true,"label":"mismatched closing delimiter","line_end":40,"line_start":40,"suggested_replacement":null,"suggestion_applicability":null,"text":[{"highlight_end":29,"highlight_start":28,"text":"            stack.push([']')"}]},{"byte_end":2024,"byte_start":2023,"column_end":24,"column_start":23,"expansion":null,"file_name":"src/bin/rust_1.rs","is_primary":false,"label":"closing delimiter possibly meant for this","line_end":40,"line_start":40,"suggested_replacement":null,"suggestion_applicability":null,"text":[{"highlight_end":24,"highlight_start":23,"text":"            stack.push([']')"}]},{"byte_end":2025,"byte_start":2024,"column_end":25,"column_start":24,"expansion":null,"file_name":"src/bin/rust_1.rs","is_primary":true,"label":"unclosed delimiter","line_end":40,"line_start":40,"suggested_replacement":null,"suggestion_applicability":null,"text":[{"highlight_end":25,"highlight_start":24,"text":"            stack.push([']')"}]}]}}
{"reason":"compiler-message","package_id":"path+file:///workspace/CodeGeeX/codegeex/benchmark/rust#0.1.0","manifest_path":"/workspace/CodeGeeX/codegeex/benchmark/rust/Cargo.toml","target":{"kind":["bin"],"crate_types":["bin"],"name":"rust_1","src_path":"/workspace/CodeGeeX/codegeex/benchmark/rust/src/bin/rust_1.rs","edition":"2021","doc":true,"doctest":false,"test":true},"message":{"rendered":"error: mismatched closing delimiter: `)`\n  --> src/bin/rust_1.rs:22:43\n   |\n22 |   for (let i = 0; i < str.length; i += 1) {\n   |                                           ^ unclosed delimiter\n...\n46 |         r = str[i + 2].match(/\\w+(?=\\))/) // extract next word after parentheses (which ends in )/), e.g., (\"foo\" (bar baz))\n   |                                         ^ mismatched closing delimiter\n\n","$message_type":"diagnostic","children":[],"code":null,"level":"error","message":"mismatched closing delimiter: `)`","spans":[{"byte_end":2154,"byte_start":2153,"column_end":42,"column_start":41,"expansion":null,"file_name":"src/bin/rust_1.rs","is_primary":true,"label":"mismatched closing delimiter","line_end":46,"line_start":46,"suggested_replacement":null,"suggestion_applicability":null,"text":[{"highlight_end":42,"highlight_start":41,"text":"        r = str[i + 2].match(/\\w+(?=\\))/) // extract next word after parentheses (which ends in )/), e.g., (\"foo\" (bar baz))"}]},{"byte_end":713,"byte_start":712,"column_end":44,"column_start":43,"expansion":null,"file_name":"src/bin/rust_1.rs","is_primary":true,"label":"unclosed delimiter","line_end":22,"line_start":22,"suggested_replacement":null,"suggestion_applicability":null,"text":[{"highlight_end":44,"highlight_start":43,"text":"  for (let i = 0; i < str.length; i += 1) {"}]}]}}
{"reason":"compiler-message","package_id":"path+file:///workspace/CodeGeeX/codegeex/benchmark/rust#0.1.0","manifest_path":"/workspace/CodeGeeX/codegeex/benchmark/rust/Cargo.toml","target":{"kind":["bin"],"crate_types":["bin"],"name":"rust_1","src_path":"/workspace/CodeGeeX/codegeex/benchmark/rust/src/bin/rust_1.rs","edition":"2021","doc":true,"doctest":false,"test":true},"message":{"rendered":"error: this file contains an unclosed delimiter\n  --> src/bin/rust_1.rs:74:3\n   |\n11 | fn separate_paren_groups(paren_string: String) -> Vec<String>{\n   |                                                              - unclosed delimiter\n...\n29 |           stack.push([']')\n   |                          - missing open `(` for this delimiter\n...\n35 |       let r = str[i + 1].match(/\\w+(?=\\))/) // word immediately after parentheses (which ends in )/), e.g., (\"foo\" (bar baz))\n   |                                           - missing open `(` for this delimiter\n...\n38 |         while (!str[stack[stack.length - 1].length + 1].match(/(\\w+)\\s*?\\)/)) { // as long as there is no word after the parentheses, con...\n   |                                                                             - missing open `(` for this delimiter\n39 |           if (str[stack[stack.length - 1].length] === '(') { // match character in string to open-paren, push that character onto top of ...\n40 |             stack.push([']')\n   |                            - missing open `(` for this delimiter\n...\n46 |         r = str[i + 2].match(/\\w+(?=\\))/) // extract next word after parentheses (which ends in )/), e.g., (\"foo\" (bar baz))\n   |                                         - missing open `(` for this delimiter\n...\n74 | }\n   |   ^\n\n","$message_type":"diagnostic","children":[],"code":null,"level":"error","message":"this file contains an unclosed delimiter","spans":[{"byte_end":270,"byte_start":269,"column_end":63,"column_start":62,"expansion":null,"file_name":"src/bin/rust_1.rs","is_primary":false,"label":"unclosed delimiter","line_end":11,"line_start":11,"suggested_replacement":null,"suggestion_applicability":null,"text":[{"highlight_end":63,"highlight_start":62,"text":"fn separate_paren_groups(paren_string: String) -> Vec<String>{"}]},{"byte_end":1294,"byte_start":1294,"column_end":26,"column_start":26,"expansion":null,"file_name":"src/bin/rust_1.rs","is_primary":false,"label":"missing open `(` for this delimiter","line_end":29,"line_start":29,"suggested_replacement":null,"suggestion_applicability":null,"text":[{"highlight_end":26,"highlight_start":26,"text":"          stack.push([']')"}]},{"byte_end":1411,"byte_start":1411,"column_end":43,"column_start":43,"expansion":null,"file_name":"src/bin/rust_1.rs","is_primary":false,"label":"missing open `(` for this delimiter","line_end":35,"line_start":35,"suggested_replacement":null,"suggestion_applicability":null,"text":[{"highlight_end":43,"highlight_start":43,"text":"      let r = str[i + 1].match(/\\w+(?=\\))/) // word immediately after parentheses (which ends in )/), e.g., (\"foo\" (bar baz))"}]},{"byte_end":1763,"byte_start":1763,"column_end":77,"column_start":77,"expansion":null,"file_name":"src/bin/rust_1.rs","is_primary":false,"label":"missing open `(` for this delimiter","line_end":38,"line_start":38,"suggested_replacement":null,"suggestion_applicability":null,"text":[{"highlight_end":77,"highlight_start":77,"text":"        while (!str[stack[stack.length - 1].length + 1].match(/(\\w+)\\s*?\\)/)) { // as long as there is no word after the parentheses, continue pushing that onto the stack"}]},{"byte_end":2028,"byte_start":2028,"column_end":28,"column_start":28,"expansion":null,"file_name":"src/bin/rust_1.rs","is_primary":false,"label":"missing open `(` for this delimiter","line_end":40,"line_start":40,"suggested_replacement":null,"suggestion_applicability":null,"text":[{"highlight_end":28,"highlight_start":28,"text":"            stack.push([']')"}]},{"byte_end":2153,"byte_start":2153,"column_end":41,"column_start":41,"expansion":null,"file_name":"src/bin/rust_1.rs","is_primary":false,"label":"missing open `(` for this delimiter","line_end":46,"line_start":46,"suggested_replacement":null,"suggestion_applicability":null,"text":[{"highlight_end":41,"highlight_start":41,"text":"        r = str[i + 2].match(/\\w+(?=\\))/) // extract next word after parentheses (which ends in )/), e.g., (\"foo\" (bar baz))"}]},{"byte_end":2981,"byte_start":2981,"column_end":3,"column_start":3,"expansion":null,"file_name":"src/bin/rust_1.rs","is_primary":true,"label":null,"line_end":74,"line_start":74,"suggested_replacement":null,"suggestion_applicability":null,"text":[{"highlight_end":3,"highlight_start":3,"text":"}"}]}]}}
{"reason":"compiler-message","package_id":"path+file:///workspace/CodeGeeX/codegeex/benchmark/rust#0.1.0","manifest_path":"/workspace/CodeGeeX/codegeex/benchmark/rust/Cargo.toml","target":{"kind":["bin"],"crate_types":["bin"],"name":"rust_1","src_path":"/workspace/CodeGeeX/codegeex/benchmark/rust/src/bin/rust_1.rs","edition":"2021","doc":true,"doctest":false,"test":true},"message":{"rendered":"error: aborting due to 20 previous errors\n\n","$message_type":"diagnostic","children":[],"code":null,"level":"error","message":"aborting due to 20 previous errors","spans":[]}}
{"reason":"build-finished","success":false}
