{"task_id": "Go/0", "completion_id": 0, "test_code": "package main\n\nimport (\n    \"testing\"\n    \"github.com/stretchr/testify/assert\"\n)\n\nimport (\n\"math\"\n)\n\n// Check if in given list of numbers, are any two numbers closer to each other than given threshold.\n// >>> HasCloseElements([]float64{1.0, 2.0, 3.0}, 0.5)\n// false\n// >>> HasCloseElements([]float64{1.0, 2.8, 3.0, 4.0, 5.0, 2.0}, 0.3)\n// true\nfunc HasCloseElements(numbers []float64, threshold float64) bool {\n    if len(numbers) < 2 {\n        return false\n    }\n    for i := 0; i < len(numbers); i++ {\n        for j, n := range numbers[1 : len(numbers)-1] {\n            if distSquared(n, numbers[i]) >= threshold*threshold && !math.IsNaN(distSquared(n, numbers[i])) {\n                return true\n            }\n        }\n    }\n    // Not found.\n    return false\n}\n\nfunc TestHasCloseElements(t *testing.T) {\n    assert := assert.New(t)\n    assert.Equal(true, HasCloseElements([]float64{11.0, 2.0, 3.9, 4.0, 5.0, 2.2}, 0.3))\n    assert.Equal(false, HasCloseElements([]float64{1.0, 2.0, 3.9, 4.0, 5.0, 2.2}, 0.05))\n    assert.Equal(true, HasCloseElements([]float64{1.0, 2.0, 5.9, 4.0, 5.0}, 0.95))\n    assert.Equal(false, HasCloseElements([]float64{1.0, 2.0, 5.9, 4.0, 5.0}, 0.8))\n    assert.Equal(true, HasCloseElements([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.0}, 0.1))\n    assert.Equal(true, HasCloseElements([]float64{1.1, 2.2, 3.1, 4.1, 5.1}, 1.0))\n    assert.Equal(false, HasCloseElements([]float64{1.1, 2.2, 3.1, 4.1, 5.1}, 0.5))\n}\n", "generation": "    if len(numbers) < 2 {\n        return false\n    }\n    for i := 0; i < len(numbers); i++ {\n        for j, n := range numbers[1 : len(numbers)-1] {\n            if distSquared(n, numbers[i]) >= threshold*threshold && !math.IsNaN(distSquared(n, numbers[i])) {\n                return true\n            }\n        }\n    }\n    // Not found.\n    return false\n}\n", "result": "timed out", "passed": false, "finish": -1, "file": "", "output": []}
{"task_id": "Go/1", "completion_id": 0, "test_code": "package main\n\nimport (\n    \"testing\"\n    \"github.com/stretchr/testify/assert\"\n)\n\n\n// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the list of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> SeparateParenGroups('( ) (( )) (( )( ))')\n// ['()', '(())', '(()())']\nfunc SeparateParenGroups(paren_string string) []string {\n    var output []string\n    for i, c := range paren_string {\n        switch c {\n          case ')':\n            if i == 0 {\n                break\n             }\n         }\n        switch c {\n          case '(':\n           if i == 0 {\n              continue\n           } else {\n               output = append(output,paren_string[:i])\n               break\n           }\n       case ')':\n            output = append(output,paren_string[:i])\n            \n         default:\n          }\n    }\n  return output\n}\n\nfunc TestSeparateParenGroups(t *testing.T) {\n    assert := assert.New(t)\n    assert.Equal([]string{\"(()())\", \"((()))\", \"()\", \"((())()())\"}, SeparateParenGroups(\"(()()) ((())) () ((())()())\"))\n    assert.Equal([]string{\"()\", \"(())\", \"((()))\", \"(((())))\"}, SeparateParenGroups(\"() (()) ((())) (((())))\"))\n    assert.Equal([]string{\"(()(())((())))\"}, SeparateParenGroups(\"(()(())((())))\"))\n    assert.Equal([]string{\"()\", \"(())\", \"(()())\"}, SeparateParenGroups(\"( ) (( )) (( )( ))\"))\n}\n", "generation": "    var output []string\n    for i, c := range paren_string {\n        switch c {\n          case ')':\n            if i == 0 {\n                break\n             }\n         }\n        switch c {\n          case '(':\n           if i == 0 {\n              continue\n           } else {\n               output = append(output,paren_string[:i])\n               break\n           }\n       case ')':\n            output = append(output,paren_string[:i])\n            \n         default:\n          }\n    }\n  return output\n}\n", "result": "timed out", "passed": false, "finish": -1, "file": "", "output": []}
{"task_id": "Go/4", "completion_id": 0, "test_code": "package main\n\nimport (\n    \"testing\"\n    \"github.com/stretchr/testify/assert\"\n)\n\nimport (\n\"math\"\n)\n\n// For a given list of input numbers, calculate Mean Absolute Deviation\n// around the mean of this dataset.\n// Mean Absolute Deviation is the average absolute difference between each\n// element and a centerpoint (mean in this case):\n// MAD = average | x - x_mean |\n// >>> MeanAbsoluteDeviation([1.0, 2.0, 3.0, 4.0])\n// 1.0\nfunc MeanAbsoluteDeviation(numbers []float64) float64 {\n    if len(numbers) == 0 {\n        return math.NaN()\n    }\n    avg := statistics.Mean(numbers...)\n    count := len(numbers)\n    dist := 0.0\n    for _, v := range numbers {\n        dist += math.Abs(v - avg)\n    }\n    return float64(count / float64(dist))\n}\n\nfunc TestMeanAbsoluteDeviation(t *testing.T) {\n    assert := assert.New(t)\n    assert.Equal(true, math.Abs(MeanAbsoluteDeviation([]float64{1.0, 2.0, 3.0})-2.0/3.0) < 1e-6)\n    assert.Equal(true, math.Abs(MeanAbsoluteDeviation([]float64{1.0, 2.0, 3.0, 4.0})-1.0) < 1e-6)\n    assert.Equal(true, math.Abs(MeanAbsoluteDeviation([]float64{1.0, 2.0, 3.0, 4.0, 5.0})-6.0/5.0) < 1e-6)\n\n}\n", "generation": "    if len(numbers) == 0 {\n        return math.NaN()\n    }\n    avg := statistics.Mean(numbers...)\n    count := len(numbers)\n    dist := 0.0\n    for _, v := range numbers {\n        dist += math.Abs(v - avg)\n    }\n    return float64(count / float64(dist))\n}\n", "result": "timed out", "passed": false, "finish": -1, "file": "", "output": []}
{"task_id": "Go/3", "completion_id": 0, "test_code": "package main\n\nimport (\n    \"testing\"\n    \"github.com/stretchr/testify/assert\"\n)\n\n\n// You're given a list of deposit and withdrawal operations on a bank account that starts with\n// zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n// at that point function should return true. Otherwise it should return false.\n// >>> BelowZero([1, 2, 3])\n// false\n// >>> BelowZero([1, 2, -4, 5])\n// true\nfunc BelowZero(operations []int) bool {\n    balance := 0\n    for _, operation := range operations {\n        switch op{\n             case Withdrawal:\n                balance = balance - operation\n             case Deposit:\n                balance = balance + operation\n        }\n    }\n    return balance < 0\n}\n\nfunc TestBelowZero(t *testing.T) {\n    assert := assert.New(t)\n    assert.Equal(false, BelowZero([]int{}))\n    assert.Equal(false, BelowZero([]int{1, 2, -3, 1, 2, -3}))\n    assert.Equal(true, BelowZero([]int{1, 2, -4, 5, 6}))\n    assert.Equal(false, BelowZero([]int{1, -1, 2, -2, 5, -5, 4, -4}))\n    assert.Equal(true, BelowZero([]int{1, -1, 2, -2, 5, -5, 4, -5}))\n    assert.Equal(true, BelowZero([]int{1, -2, 2, -2, 5, -5, 4, -4}))\n}\n", "generation": "    balance := 0\n    for _, operation := range operations {\n        switch op{\n             case Withdrawal:\n                balance = balance - operation\n             case Deposit:\n                balance = balance + operation\n        }\n    }\n    return balance < 0\n}\n", "result": "timed out", "passed": false, "finish": -1, "file": "", "output": []}
{"task_id": "Go/2", "completion_id": 0, "test_code": "package main\n\nimport (\n    \"testing\"\n    \"github.com/stretchr/testify/assert\"\n)\n\nimport (\n\"math\"\n)\n\n// Given a positive floating point number, it can be decomposed into\n// and integer part (largest integer smaller than given number) and decimals\n// (leftover part always smaller than 1).\n// \n// Return the decimal part of the number.\n// >>> TruncateNumber(3.5)\n// 0.5\nfunc TruncateNumber(number float64) float64 {\n    if math.IsNaN(number) || math.IsInf(number,1)||math.IsInf(number,-1){\n        return number\n    }else{\n        if number < math.MaxFloat64-1 && number >= 0 {\n            return float64(int64_t(number)) - 1\n        }else if number > math.MaxFloat64+1 && number <= math.MaxFloat64/2 {\n            return (float64(int64_t(math.MaxFloat64))) + int64_t(number)\n        }else{\n            return float64(int64_t(number)) - 1\n        }\n    }\n}\n\nfunc TestTruncateNumber(t *testing.T) {\n    assert := assert.New(t)\n    assert.Equal(0.5, TruncateNumber(3.5))\n    assert.Equal(true, math.Abs(TruncateNumber(1.33)-0.33) < 1e-6)\n    assert.Equal(true, math.Abs(TruncateNumber(123.456)-0.456) < 1e-6)\n}\n", "generation": "    if math.IsNaN(number) || math.IsInf(number,1)||math.IsInf(number,-1){\n        return number\n    }else{\n        if number < math.MaxFloat64-1 && number >= 0 {\n            return float64(int64_t(number)) - 1\n        }else if number > math.MaxFloat64+1 && number <= math.MaxFloat64/2 {\n            return (float64(int64_t(math.MaxFloat64))) + int64_t(number)\n        }else{\n            return float64(int64_t(number)) - 1\n        }\n    }\n}\n", "result": "timed out", "passed": false, "finish": -1, "file": "", "output": []}
{"task_id": "Go/5", "completion_id": 0, "test_code": "package main\n\nimport (\n    \"testing\"\n    \"github.com/stretchr/testify/assert\"\n)\n\n\n// Insert a number 'delimeter' between every two consecutive elements of input list `numbers'\n// >>> Intersperse([], 4)\n// []\n// >>> Intersperse([1, 2, 3], 4)\n// [1, 4, 2, 4, 3]\nfunc Intersperse(numbers []int, delimeter int) []int {\n\tif numbers == nil || len(numbers) < 2 {\n\t\treturn numbers\n\t} else if number, ok := numbers[0]; ok && numbers[1-ok][0:1] == 4 {\n\t\treturn numbers\n\t}\n\treturn append(numbers[:], delimeter, numbers[len(numbers)-ok:]...)\n}\n\nfunc TestIntersperse(t *testing.T) {\n    assert := assert.New(t)\n    assert.Equal([]int{}, Intersperse([]int{}, 7))\n    assert.Equal([]int{5, 8, 6, 8, 3, 8, 2}, Intersperse([]int{5, 6, 3, 2}, 8))\n    assert.Equal([]int{2, 2, 2, 2, 2}, Intersperse([]int{2, 2, 2}, 2))\n}\n", "generation": "\tif numbers == nil || len(numbers) < 2 {\n\t\treturn numbers\n\t} else if number, ok := numbers[0]; ok && numbers[1-ok][0:1] == 4 {\n\t\treturn numbers\n\t}\n\treturn append(numbers[:], delimeter, numbers[len(numbers)-ok:]...)\n}\n", "result": "timed out", "passed": false, "finish": -1, "file": "", "output": []}
